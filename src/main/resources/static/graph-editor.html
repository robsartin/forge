<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Editor</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }
        .graph-editor {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }
        .sidebar h2 {
            font-size: 1rem;
            color: #333;
            margin-bottom: 16px;
        }
        .form-group {
            margin-bottom: 16px;
        }
        .form-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.875rem;
            color: #555;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.875rem;
        }
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #3498db;
            color: white;
            width: 100%;
        }
        .btn-primary:hover {
            background: #2980b9;
        }
        .btn-secondary {
            background: #95a5a6;
            color: white;
            margin-top: 8px;
            width: 100%;
        }
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background: #c0392b;
        }
        .graph-container {
            flex: 1;
            background: white;
            position: relative;
        }
        .graph-svg {
            width: 100%;
            height: 100%;
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 2px;
            transition: all 0.2s;
        }
        .node:hover circle {
            fill: #2980b9;
            stroke: #1a5276;
        }
        .node.selected circle {
            fill: #e74c3c;
            stroke: #c0392b;
        }
        .node text {
            font-size: 12px;
            fill: white;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            font-weight: 500;
        }
        .link {
            stroke: #95a5a6;
            stroke-width: 2px;
            fill: none;
        }
        .link-arrow {
            fill: #95a5a6;
        }
        .graph-list {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .graph-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .graph-item:hover {
            background: #e9ecef;
        }
        .graph-item.active {
            background: #d4edda;
            border: 1px solid #28a745;
        }
        .graph-item-name {
            font-size: 0.875rem;
            font-weight: 500;
        }
        .node-list {
            margin-top: 16px;
        }
        .node-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }
        .edge-form {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        .status-bar {
            background: #34495e;
            color: #bdc3c7;
            padding: 8px 16px;
            font-size: 0.75rem;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #7f8c8d;
        }
        .error {
            color: #e74c3c;
            padding: 10px;
            background: #fce4e4;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 0.875rem;
        }
        .instructions {
            background: #e8f4fd;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 0.8rem;
            color: #2c3e50;
        }
        .instructions ul {
            margin-left: 16px;
            margin-top: 8px;
        }
        .node-edit-input {
            position: absolute;
            background: white;
            border: 2px solid #3498db;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 14px;
            min-width: 100px;
            transform: translate(-50%, -50%);
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        .node-edit-input:focus {
            outline: none;
            border-color: #2980b9;
        }
        .drag-line {
            stroke: #3498db;
            stroke-width: 2px;
            stroke-dasharray: 5,5;
            fill: none;
            pointer-events: none;
        }
        .node.drag-source circle {
            fill: #27ae60;
            stroke: #1e8449;
        }
        .node.drag-target circle {
            fill: #9b59b6;
            stroke: #7d3c98;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        const { useState, useEffect, useRef, useCallback } = React;

        const API_BASE = '';

        // API functions
        const api = {
            async getGraphs() {
                const res = await fetch(`${API_BASE}/graphs`);
                return res.json();
            },
            async createGraph(name) {
                const res = await fetch(`${API_BASE}/graphs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                return res.json();
            },
            async deleteGraph(id) {
                await fetch(`${API_BASE}/graphs/${id}`, { method: 'DELETE' });
            },
            async getNodes(graphId) {
                const res = await fetch(`${API_BASE}/graphs/${graphId}/nodes`);
                return res.json();
            },
            async createNode(graphId, name) {
                const res = await fetch(`${API_BASE}/graphs/${graphId}/nodes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                return res.json();
            },
            async addEdge(graphId, fromId, toId) {
                await fetch(`${API_BASE}/graphs/${graphId}/nodes/${fromId}/${toId}`, {
                    method: 'POST'
                });
            },
            async getNodeWithLinks(graphId, nodeId) {
                const res = await fetch(`${API_BASE}/graphs/${graphId}/nodes/${nodeId}`);
                return res.json();
            },
            async updateNode(graphId, nodeId, name) {
                const res = await fetch(`${API_BASE}/graphs/${graphId}/nodes/${nodeId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                return res.json();
            }
        };

        // D3 Graph Visualization Component
        function GraphVisualization({ nodes, edges, selectedNode, editingNode, onNodeClick, onCanvasClick, onEdgeCreate, onEditStart }) {
            const svgRef = useRef(null);
            const simulationRef = useRef(null);
            const dragLineRef = useRef(null);
            const dragSourceRef = useRef(null);
            const transformRef = useRef(d3.zoomIdentity);
            const nodePositionsRef = useRef(new Map()); // Store node positions

            useEffect(() => {
                if (!svgRef.current) return;

                const svg = d3.select(svgRef.current);
                const width = svgRef.current.clientWidth;
                const height = svgRef.current.clientHeight;

                // Preserve positions from previous render
                nodes.forEach(n => {
                    const storedPos = nodePositionsRef.current.get(n.id);
                    if (storedPos) {
                        n.x = storedPos.x;
                        n.y = storedPos.y;
                    }
                });

                svg.selectAll('*').remove();

                // Add arrow marker definition
                const defs = svg.append('defs');
                defs.append('marker')
                    .attr('id', 'arrowhead')
                    .attr('viewBox', '-0 -5 10 10')
                    .attr('refX', 30)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .append('path')
                    .attr('d', 'M 0,-5 L 10,0 L 0,5')
                    .attr('class', 'link-arrow');

                const g = svg.append('g');

                // Add drag line (initially hidden)
                const dragLine = g.append('line')
                    .attr('class', 'drag-line')
                    .style('display', 'none');
                dragLineRef.current = dragLine;

                // Add zoom behavior
                const zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .filter((event) => {
                        // Allow zoom on scroll and right-click drag, but not on left-click
                        return event.type === 'wheel' || event.button === 2;
                    })
                    .on('zoom', (event) => {
                        transformRef.current = event.transform;
                        g.attr('transform', event.transform);
                    });
                svg.call(zoom);

                // Handle canvas click to create node
                svg.on('click', (event) => {
                    // Only create node if clicking directly on the SVG (not on a node)
                    if (event.target === svgRef.current) {
                        const [x, y] = d3.pointer(event, g.node());
                        onCanvasClick(x, y);
                    }
                });

                // Check if we have stored positions (meaning this is a re-render, not initial load)
                const hasStoredPositions = nodes.some(n => nodePositionsRef.current.has(n.id));

                // Create force simulation
                const simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(edges).id(d => d.id).distance(150))
                    .force('charge', d3.forceManyBody().strength(-400))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(50));

                // If we have stored positions, reduce simulation intensity
                if (hasStoredPositions) {
                    simulation.alpha(0.1).alphaDecay(0.05);
                }

                simulationRef.current = simulation;

                // Draw edges
                const link = g.append('g')
                    .selectAll('line')
                    .data(edges)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('marker-end', 'url(#arrowhead)');

                // Helper function to find node at position
                const findNodeAtPosition = (x, y, excludeId) => {
                    const nodeRadius = 25;
                    for (const n of nodes) {
                        if (n.id === excludeId) continue;
                        const dx = n.x - x;
                        const dy = n.y - y;
                        if (Math.sqrt(dx * dx + dy * dy) <= nodeRadius) {
                            return n;
                        }
                    }
                    return null;
                };

                // Draw nodes
                const node = g.append('g')
                    .selectAll('.node')
                    .data(nodes)
                    .enter()
                    .append('g')
                    .attr('class', d => `node ${selectedNode === d.id ? 'selected' : ''} ${editingNode === d.id ? 'editing' : ''}`)
                    .call(d3.drag()
                        .on('start', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            // Fix node in place (don't let it move during edge creation)
                            d.fx = d.x;
                            d.fy = d.y;
                            dragSourceRef.current = d;
                            // Show drag line from node center
                            dragLine
                                .style('display', null)
                                .attr('x1', d.x)
                                .attr('y1', d.y)
                                .attr('x2', d.x)
                                .attr('y2', d.y);
                            // Highlight source node
                            d3.select(event.sourceEvent.target.closest('.node')).classed('drag-source', true);
                        })
                        .on('drag', (event, d) => {
                            // DON'T move the node - just update the drag line
                            // Keep node fixed at original position
                            dragLine
                                .attr('x2', event.x)
                                .attr('y2', event.y);
                            // Highlight potential target node
                            const targetNode = findNodeAtPosition(event.x, event.y, d.id);
                            node.classed('drag-target', n => targetNode && n.id === targetNode.id);
                        })
                        .on('end', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            // Release the node so simulation can move it
                            d.fx = null;
                            d.fy = null;
                            // Hide drag line
                            dragLine.style('display', 'none');
                            // Remove highlights
                            node.classed('drag-source', false);
                            node.classed('drag-target', false);
                            // Check if dropped on another node
                            const targetNode = findNodeAtPosition(event.x, event.y, d.id);
                            if (targetNode && dragSourceRef.current) {
                                onEdgeCreate(dragSourceRef.current.id, targetNode.id);
                            }
                            dragSourceRef.current = null;
                        })
                    )
                    .on('click', (event, d) => {
                        event.stopPropagation();
                        // If already editing this node, don't restart
                        if (editingNode === d.id) return;
                        // Check if this was a drag or a click
                        if (event.defaultPrevented) return;
                        // Start editing mode for the node
                        onEditStart(d);
                    });

                node.append('circle')
                    .attr('r', 25);

                node.append('text')
                    .text(d => d.name.length > 8 ? d.name.substring(0, 7) + '...' : d.name);

                // Update positions on each tick and save to ref
                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node.attr('transform', d => `translate(${d.x},${d.y})`);

                    // Save positions to ref for persistence across re-renders
                    nodes.forEach(n => {
                        nodePositionsRef.current.set(n.id, { x: n.x, y: n.y });
                    });
                });

                return () => simulation.stop();
            }, [nodes, edges, selectedNode, editingNode, onNodeClick, onCanvasClick, onEdgeCreate, onEditStart]);

            return <svg ref={svgRef} className="graph-svg" />;
        }

        // Main App Component
        function GraphEditor() {
            const [graphs, setGraphs] = useState([]);
            const [selectedGraph, setSelectedGraph] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [edges, setEdges] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [editingNode, setEditingNode] = useState(null);
            const [editingName, setEditingName] = useState('');
            const [editingPosition, setEditingPosition] = useState({ x: 0, y: 0 });
            const [newGraphName, setNewGraphName] = useState('');
            const [newNodeName, setNewNodeName] = useState('');
            const [edgeFrom, setEdgeFrom] = useState('');
            const [edgeTo, setEdgeTo] = useState('');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [status, setStatus] = useState('Ready');
            const graphContainerRef = useRef(null);

            // Load graphs on mount
            useEffect(() => {
                loadGraphs();
            }, []);

            const loadGraphs = async () => {
                try {
                    setLoading(true);
                    const data = await api.getGraphs();
                    setGraphs(data);
                    setStatus(`Loaded ${data.length} graphs`);
                } catch (err) {
                    setError('Failed to load graphs');
                } finally {
                    setLoading(false);
                }
            };

            const loadGraphData = async (graphId) => {
                try {
                    setLoading(true);
                    const nodeData = await api.getNodes(graphId);
                    setNodes(nodeData.map(n => ({ ...n, x: Math.random() * 500, y: Math.random() * 400 })));

                    // Load edges for each node
                    const edgeList = [];
                    for (const node of nodeData) {
                        const nodeWithLinks = await api.getNodeWithLinks(graphId, node.id);
                        for (const toNode of nodeWithLinks.toNodes || []) {
                            edgeList.push({ source: node.id, target: toNode.id });
                        }
                    }
                    setEdges(edgeList);
                    setStatus(`Loaded graph with ${nodeData.length} nodes and ${edgeList.length} edges`);
                } catch (err) {
                    setError('Failed to load graph data');
                } finally {
                    setLoading(false);
                }
            };

            const handleSelectGraph = (graph) => {
                setSelectedGraph(graph);
                setSelectedNode(null);
                loadGraphData(graph.id);
            };

            const handleCreateGraph = async () => {
                if (!newGraphName.trim()) return;
                try {
                    const newGraph = await api.createGraph(newGraphName);
                    setGraphs([...graphs, newGraph]);
                    setNewGraphName('');
                    setStatus(`Created graph: ${newGraphName}`);
                } catch (err) {
                    setError('Failed to create graph');
                }
            };

            const handleDeleteGraph = async (graphId) => {
                try {
                    await api.deleteGraph(graphId);
                    setGraphs(graphs.filter(g => g.id !== graphId));
                    if (selectedGraph?.id === graphId) {
                        setSelectedGraph(null);
                        setNodes([]);
                        setEdges([]);
                    }
                    setStatus('Graph deleted');
                } catch (err) {
                    setError('Failed to delete graph');
                }
            };

            const handleCreateNode = async () => {
                if (!selectedGraph || !newNodeName.trim()) return;
                try {
                    const newNode = await api.createNode(selectedGraph.id, newNodeName);
                    setNodes([...nodes, { ...newNode, x: 400, y: 300 }]);
                    setNewNodeName('');
                    setStatus(`Created node: ${newNodeName}`);
                } catch (err) {
                    setError('Failed to create node');
                }
            };

            const handleAddEdge = async () => {
                if (!selectedGraph || !edgeFrom || !edgeTo) return;
                try {
                    await api.addEdge(selectedGraph.id, edgeFrom, edgeTo);
                    setEdges([...edges, { source: edgeFrom, target: edgeTo }]);
                    setEdgeFrom('');
                    setEdgeTo('');
                    setStatus('Edge added');
                } catch (err) {
                    setError('Failed to add edge');
                }
            };

            const handleNodeClick = useCallback((nodeId) => {
                setSelectedNode(nodeId === selectedNode ? null : nodeId);
            }, [selectedNode]);

            // Handle canvas click to create a new node
            const handleCanvasClick = useCallback(async (x, y) => {
                if (!selectedGraph) return;
                const nodeName = `Node ${nodes.length + 1}`;
                try {
                    const newNode = await api.createNode(selectedGraph.id, nodeName);
                    setNodes(prev => [...prev, { ...newNode, x, y }]);
                    setStatus(`Created node: ${nodeName}`);
                    // Immediately start editing the new node
                    setTimeout(() => {
                        const container = graphContainerRef.current;
                        if (container) {
                            const rect = container.getBoundingClientRect();
                            setEditingNode(newNode.id);
                            setEditingName(nodeName);
                            setEditingPosition({ x: x + rect.left + 300, y: y + rect.top + 56 }); // Account for sidebar and header
                        }
                    }, 50);
                } catch (err) {
                    setError('Failed to create node');
                }
            }, [selectedGraph, nodes.length]);

            // Handle starting to edit a node name
            const handleEditStart = useCallback((node) => {
                const container = graphContainerRef.current;
                if (container) {
                    const rect = container.getBoundingClientRect();
                    setEditingNode(node.id);
                    setEditingName(node.name);
                    setEditingPosition({ x: node.x + rect.left, y: node.y + rect.top });
                }
            }, []);

            // Handle renaming a node
            const handleNodeRename = useCallback(async (newName) => {
                if (!editingNode || !newName.trim() || !selectedGraph) {
                    setEditingNode(null);
                    return;
                }
                try {
                    // Persist to backend
                    await api.updateNode(selectedGraph.id, editingNode, newName.trim());
                    // Update node name locally, preserving position
                    setNodes(prev => prev.map(n =>
                        n.id === editingNode ? { ...n, name: newName.trim() } : n
                    ));
                    setStatus(`Renamed node to: ${newName.trim()}`);
                } catch (err) {
                    setError('Failed to rename node');
                }
                setEditingNode(null);
            }, [editingNode, selectedGraph]);

            // Handle creating an edge by dragging from one node to another
            const handleEdgeCreate = useCallback(async (sourceId, targetId) => {
                if (!selectedGraph) return;
                // Check if edge already exists
                const edgeExists = edges.some(e =>
                    (e.source === sourceId || e.source?.id === sourceId) &&
                    (e.target === targetId || e.target?.id === targetId)
                );
                if (edgeExists) {
                    setStatus('Edge already exists');
                    return;
                }
                try {
                    await api.addEdge(selectedGraph.id, sourceId, targetId);
                    setEdges(prev => [...prev, { source: sourceId, target: targetId }]);
                    const sourceNode = nodes.find(n => n.id === sourceId);
                    const targetNode = nodes.find(n => n.id === targetId);
                    setStatus(`Created edge: ${sourceNode?.name} -> ${targetNode?.name}`);
                } catch (err) {
                    setError('Failed to create edge');
                }
            }, [selectedGraph, edges, nodes]);

            return (
                <div className="graph-editor">
                    <header className="header">
                        <h1>Graph Editor</h1>
                        <span>React + D3 Visualization</span>
                    </header>
                    <div className="main-content">
                        <aside className="sidebar">
                            {error && <div className="error">{error}</div>}

                            <div className="instructions">
                                <strong>How to use:</strong>
                                <ul>
                                    <li>Create or select a graph</li>
                                    <li><strong>Click canvas</strong> to create a node</li>
                                    <li><strong>Click a node</strong> to rename it</li>
                                    <li><strong>Drag from node to node</strong> to create edge</li>
                                    <li>Scroll to zoom, drag to reposition</li>
                                </ul>
                            </div>

                            <h2>Create New Graph</h2>
                            <div className="form-group">
                                <label>Graph Name</label>
                                <input
                                    type="text"
                                    value={newGraphName}
                                    onChange={e => setNewGraphName(e.target.value)}
                                    placeholder="Enter graph name"
                                    onKeyPress={e => e.key === 'Enter' && handleCreateGraph()}
                                />
                            </div>
                            <button className="btn btn-primary" onClick={handleCreateGraph}>
                                Create Graph
                            </button>

                            <div className="graph-list">
                                <h2>Existing Graphs</h2>
                                {graphs.map(graph => (
                                    <div
                                        key={graph.id}
                                        className={`graph-item ${selectedGraph?.id === graph.id ? 'active' : ''}`}
                                        onClick={() => handleSelectGraph(graph)}
                                    >
                                        <span className="graph-item-name">{graph.name}</span>
                                        <button
                                            className="btn btn-danger"
                                            onClick={e => {
                                                e.stopPropagation();
                                                handleDeleteGraph(graph.id);
                                            }}
                                            style={{ padding: '4px 8px', fontSize: '0.7rem' }}
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>

                            {selectedGraph && (
                                <>
                                    <div className="node-list">
                                        <h2>Add Node</h2>
                                        <div className="form-group">
                                            <label>Node Name</label>
                                            <input
                                                type="text"
                                                value={newNodeName}
                                                onChange={e => setNewNodeName(e.target.value)}
                                                placeholder="Enter node name"
                                                onKeyPress={e => e.key === 'Enter' && handleCreateNode()}
                                            />
                                        </div>
                                        <button className="btn btn-primary" onClick={handleCreateNode}>
                                            Add Node
                                        </button>
                                    </div>

                                    {nodes.length >= 2 && (
                                        <div className="edge-form">
                                            <h2>Add Edge</h2>
                                            <div className="form-group">
                                                <label>From Node</label>
                                                <select value={edgeFrom} onChange={e => setEdgeFrom(e.target.value)}>
                                                    <option value="">Select node...</option>
                                                    {nodes.map(n => (
                                                        <option key={n.id} value={n.id}>{n.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <div className="form-group">
                                                <label>To Node</label>
                                                <select value={edgeTo} onChange={e => setEdgeTo(e.target.value)}>
                                                    <option value="">Select node...</option>
                                                    {nodes.map(n => (
                                                        <option key={n.id} value={n.id}>{n.name}</option>
                                                    ))}
                                                </select>
                                            </div>
                                            <button className="btn btn-primary" onClick={handleAddEdge}>
                                                Add Edge
                                            </button>
                                        </div>
                                    )}

                                    <div className="node-list" style={{ marginTop: '20px' }}>
                                        <h2>Nodes ({nodes.length})</h2>
                                        {nodes.map(node => (
                                            <div key={node.id} className="node-item">
                                                <span>{node.name}</span>
                                                <span style={{ color: '#7f8c8d', fontSize: '0.7rem' }}>
                                                    {node.id.substring(0, 8)}...
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                </>
                            )}
                        </aside>
                        <main className="graph-container" ref={graphContainerRef}>
                            {loading ? (
                                <div className="loading">Loading...</div>
                            ) : selectedGraph ? (
                                <GraphVisualization
                                    nodes={nodes}
                                    edges={edges}
                                    selectedNode={selectedNode}
                                    editingNode={editingNode}
                                    onNodeClick={handleNodeClick}
                                    onCanvasClick={handleCanvasClick}
                                    onEdgeCreate={handleEdgeCreate}
                                    onEditStart={handleEditStart}
                                />
                            ) : (
                                <div className="loading">
                                    Select a graph to visualize or create a new one
                                </div>
                            )}
                            {editingNode && (
                                <input
                                    type="text"
                                    className="node-edit-input"
                                    value={editingName}
                                    onChange={(e) => setEditingName(e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') {
                                            handleNodeRename(editingName);
                                        } else if (e.key === 'Escape') {
                                            setEditingNode(null);
                                        }
                                    }}
                                    onBlur={() => handleNodeRename(editingName)}
                                    style={{
                                        left: editingPosition.x,
                                        top: editingPosition.y
                                    }}
                                    autoFocus
                                />
                            )}
                        </main>
                    </div>
                    <footer className="status-bar">
                        {status}
                    </footer>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GraphEditor />);
    </script>
</body>
</html>
